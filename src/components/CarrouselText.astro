---
interface Props {
  items: string[];
  iconSrc?: string;
  ariaLabel?: string;
  speed?: number; // pixels per second
}

const {
  items,
  iconSrc = "/images/heart.png",
  ariaLabel = "Frases destacadas",
  speed = 90,
} = Astro.props;
const uid = `marquee-${Math.random().toString(36).slice(2)}`;
---

<section class="flower-ticker" aria-label={ariaLabel}>
  <div
    class="ticker-viewport"
    id={uid}
    data-speed={String(speed)}
    aria-hidden="false"
  >
    <div class="ticker-track">
      <ul class="ticker">
        {
          items.map((item) => (
            <li>
              <img
                class="flower-icon"
                src={iconSrc}
                alt="icono de una flor"
                aria-hidden="true"
              />{" "}
              {item}
            </li>
          ))
        }
      </ul>
    </div>
  </div>
</section>

<script type="module">
  const initMarquee = (container) => {
    const track = container.querySelector(".ticker");
    if (!track) return;

    // 1. Capture original items
    const originalItems = Array.from(track.children);
    if (originalItems.length === 0) return;

    let periodWidth = 0;
    let rafId;
    let pos = 0;

    const ensureClones = () => {
      // Clear track and re-add originals
      track.innerHTML = "";
      originalItems.forEach((item) => track.appendChild(item));

      // Add one set of clones to measure period
      originalItems.forEach((item) => {
        track.appendChild(item.cloneNode(true));
      });

      // Measure period (distance from first original to first clone)
      const firstOriginal = track.children[0];
      const firstClone = track.children[originalItems.length];
      // Use offsetLeft difference
      periodWidth = firstClone.offsetLeft - firstOriginal.offsetLeft;

      // Ensure we have enough clones to cover container + buffer
      const containerWidth = container.clientWidth || container.offsetWidth;

      // We want to be able to scroll `periodWidth` and still have content.
      // So total width should be at least containerWidth + periodWidth.

      let currentScrollWidth = track.scrollWidth;

      // Safety loop to add more clones if needed
      let loops = 0;
      while (currentScrollWidth < containerWidth + periodWidth && loops < 20) {
        originalItems.forEach((item) => {
          track.appendChild(item.cloneNode(true));
        });
        currentScrollWidth = track.scrollWidth;
        loops++;
      }
    };

    ensureClones();

    let speedPxPerSec = Number(container.dataset.speed) || 90;
    if (window.matchMedia && window.matchMedia("(max-width: 480px)").matches) {
      speedPxPerSec = Math.max(50, speedPxPerSec * 1.2);
    }

    let last = performance.now();

    const step = (now) => {
      const dt = now - last;
      last = now;
      pos += (speedPxPerSec * dt) / 1000;

      // Seamless loop: reset when we've scrolled one full period
      if (pos >= periodWidth) {
        pos -= periodWidth;
      }

      track.style.transform = `translateX(${-pos}px)`;
      rafId = requestAnimationFrame(step);
    };

    const start = () => {
      cancelAnimationFrame(rafId);
      last = performance.now();
      rafId = requestAnimationFrame(step);
    };

    let resizeTimeout;
    const onResize = () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        cancelAnimationFrame(rafId);
        ensureClones();
        pos = 0;
        track.style.transform = `translateX(0px)`;

        if (
          window.matchMedia &&
          window.matchMedia("(max-width: 480px)").matches
        ) {
          speedPxPerSec = Math.max(50, Number(container.dataset.speed) * 1.2);
        } else {
          speedPxPerSec = Number(container.dataset.speed) || 90;
        }
        start();
      }, 150);
    };

    document.addEventListener("visibilitychange", () => {
      if (document.hidden) cancelAnimationFrame(rafId);
      else {
        last = performance.now();
        rafId = requestAnimationFrame(step);
      }
    });

    container.addEventListener(
      "touchend",
      () => {
        setTimeout(() => {
          last = performance.now();
        }, 50);
      },
      { passive: true },
    );

    window.addEventListener("resize", onResize);

    start();
  };

  const mountAll = () => {
    document.querySelectorAll(".ticker-viewport").forEach(initMarquee);
  };

  if (
    document.readyState === "complete" ||
    document.readyState === "interactive"
  ) {
    setTimeout(mountAll, 0);
  } else {
    document.addEventListener("DOMContentLoaded", mountAll);
  }
</script>
